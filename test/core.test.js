// Generated by CoffeeScript 1.6.3
var TinyTotalizer, assert, vows,
  _this = this;

vows = require('vows');

assert = require('assert');

TinyTotalizer = require('../lib/tiny-totalizer');

vows.describe('core test').addBatch({
  'コンストラクタ: 引数なし': {
    topic: function() {
      return new TinyTotalizer();
    },
    '内部ハッシュが空': function(topic) {
      return assert.deepEqual(topic.hash, {});
    },
    'デフォルトオプションがセットされている': function(topic) {
      assert.isTrue(topic.opt.allowMinus);
      return assert.isZero(topic.opt.fuzzyLevel);
    }
  }
}).addBatch({
  'コンストラクタ: 初期データのハッシュの値が数値以外': {
    topic: function() {
      return new TinyTotalizer({}, {
        aaa: null,
        bbb: 'two',
        ccc: '3',
        ddd: [1, 2, 3],
        eee: new Error('error')
      });
    },
    '数値化できない値は登録されていない': function(topic) {
      return assert.deepEqual(topic.hash, {
        ccc: 3
      });
    }
  }
}).addBatch({
  'コンストラクタ: allowMinus = false': {
    topic: function() {
      var tt;
      tt = new TinyTotalizer({
        allowMinus: false
      }, {
        aaa: -1,
        bbb: 0,
        ccc: 1
      });
      tt.sub('bbb');
      return tt;
    },
    '初期で0未満の値は0になっている & sub()で0未満になっていない': function(topic) {
      return assert.deepEqual(topic.hash, {
        aaa: 0,
        bbb: 0,
        ccc: 1
      });
    }
  }
}).addBatch({
  'コンストラクタ: fuzzyLevel = 0(省略値)': {
    topic: function() {
      var tt;
      tt = new TinyTotalizer({}, {
        aaa: 0
      });
      tt.add('aaa');
      tt.add('AAA');
      tt.add('a a a');
      return tt;
    },
    'すべて別キーでカウントされている': function(topic) {
      return assert.deepEqual(topic.hash, {
        aaa: 1,
        AAA: 1,
        'a a a': 1
      });
    }
  }
}).addBatch({
  'コンストラクタ: fuzzyLevel = 1': {
    topic: function() {
      var tt;
      tt = new TinyTotalizer({
        fuzzyLevel: 1
      });
      tt.add('aaa');
      tt.add('AAA');
      tt.add('a a a');
      return tt;
    },
    '大文字小文字が同一として扱われている': function(topic) {
      return assert.deepEqual(topic.hash, {
        aaa: 2,
        'a a a': 1
      });
    }
  }
}).addBatch({
  'コンストラクタ: fuzzyLevel = 2': {
    topic: function() {
      var tt;
      tt = new TinyTotalizer({
        fuzzyLevel: 2
      });
      tt.add('aaa');
      tt.add('AAA');
      tt.add('a a a');
      return tt;
    },
    'すべて同一キーとして扱われている': function(topic) {
      return assert.deepEqual(topic.hash, {
        aaa: 3
      });
    }
  }
}).addBatch({
  'コンストラクタ: fuzzyLevel = 3': {
    topic: function() {
      return new TinyTotalizer({
        fuzzyLevel: 3
      });
    },
    '存在しないレベルなのでエラーが発生する': function(topic) {
      return assert.throws(function() {
        return topic.add('aaa');
      });
    }
  }
}).addBatch({
  'コンストラクタ: standardizer指定': {
    topic: function() {
      var tt;
      tt = new TinyTotalizer({
        fuzzyLevel: 0,
        standardizer: function(s) {
          return s.toLowerCase().replace(/[\s\-]/g, '');
        }
      });
      tt.add('aaa');
      tt.add('AAA');
      tt.add('a a a');
      tt.add('-a a a-');
      return tt;
    },
    'fuzzyLevelが3になっている': function(topic) {
      return assert.equal(topic.opt.fuzzyLevel, 3);
    },
    'standardizerで指定した関数でキーの統一化がされる': function(topic) {
      return assert.deepEqual(topic.hash, {
        aaa: 4
      });
    }
  }
}).addBatch({
  'コンストラクタ: calcReturnIsKey無指定': {
    topic: function() {
      var tt;
      tt = new TinyTotalizer({
        fuzzyLevel: 1
      });
      tt.add('aaa');
      return tt.add('AAA');
    },
    'addの戻り値はセットしたキーのカウント数': function(topic) {
      return assert.equal(topic, 2);
    }
  }
}).addBatch({
  'add: 正常な値': {
    topic: function() {
      var tt;
      tt = new TinyTotalizer({}, {
        aaa: 1
      });
      tt.add('aaa');
      tt.add('aaa', 1);
      tt.add('aaa', 2);
      tt.add('aaa', 3);
      tt.add('aaa', -1);
      return tt;
    },
    '計算結果が正しい': function(topic) {
      return assert.deepEqual(topic.hash, {
        aaa: 7
      });
    }
  }
}).addBatch({
  'add: 数値以外': {
    topic: function() {
      var tt;
      tt = new TinyTotalizer({}, {
        aaa: 1
      });
      tt.add('aaa', 'two');
      tt.add('aaa', '3');
      tt.add('aaa', ' 4 ');
      tt.add('aaa', [1, 2, 3]);
      tt.add('aaa', new Error('error'));
      return tt;
    },
    '数値化できるもののみ加算されている': function(topic) {
      return assert.deepEqual(topic.hash, {
        aaa: 8
      });
    }
  }
}).addBatch({
  'sub: 正常な値': {
    topic: function() {
      var tt;
      tt = new TinyTotalizer({}, {
        aaa: 1
      });
      tt.sub('aaa');
      tt.sub('aaa', 1);
      tt.sub('aaa', 2);
      tt.sub('aaa', 3);
      tt.sub('aaa', -1);
      return tt;
    },
    '計算結果が正しい': function(topic) {
      return assert.deepEqual(topic.hash, {
        aaa: -5
      });
    }
  }
}).addBatch({
  'sub: 数値以外': {
    topic: function() {
      var tt;
      tt = new TinyTotalizer({}, {
        aaa: 1
      });
      tt.sub('aaa', 'two');
      tt.sub('aaa', '3');
      tt.sub('aaa', ' 4 ');
      tt.sub('aaa', [1, 2, 3]);
      tt.sub('aaa', new Error('error'));
      return tt;
    },
    '数値化できるもののみ減算されている': function(topic) {
      return assert.deepEqual(topic.hash, {
        aaa: -6
      });
    }
  }
}).addBatch({
  'ranking': {
    topic: function() {
      return new TinyTotalizer({}, {
        aaa: 1,
        bbb: 2,
        ccc: 3,
        ddd: 4,
        eee: 5,
        fff: 6,
        ggg: 7,
        hhh: 8
      });
    },
    '引数なし': function(topic) {
      return assert.deepEqual(topic.ranking(), [
        {
          name: 'hhh',
          count: 8
        }, {
          name: 'ggg',
          count: 7
        }, {
          name: 'fff',
          count: 6
        }, {
          name: 'eee',
          count: 5
        }, {
          name: 'ddd',
          count: 4
        }, {
          name: 'ccc',
          count: 3
        }, {
          name: 'bbb',
          count: 2
        }, {
          name: 'aaa',
          count: 1
        }
      ]);
    },
    'border指定': function(topic) {
      return assert.deepEqual(topic.ranking({
        border: 5
      }), [
        {
          name: 'hhh',
          count: 8
        }, {
          name: 'ggg',
          count: 7
        }, {
          name: 'fff',
          count: 6
        }, {
          name: 'eee',
          count: 5
        }
      ]);
    },
    'border指定(対象がすべてborder以下)': function(topic) {
      return assert.deepEqual(topic.ranking({
        border: 100
      }), []);
    },
    'topN指定': function(topic) {
      return assert.deepEqual(topic.ranking({
        topN: 3
      }), [
        {
          name: 'hhh',
          count: 8
        }, {
          name: 'ggg',
          count: 7
        }, {
          name: 'fff',
          count: 6
        }
      ]);
    },
    'asc指定': function(topic) {
      return assert.deepEqual(topic.ranking({
        asc: true
      }), [
        {
          name: 'aaa',
          count: 1
        }, {
          name: 'bbb',
          count: 2
        }, {
          name: 'ccc',
          count: 3
        }, {
          name: 'ddd',
          count: 4
        }, {
          name: 'eee',
          count: 5
        }, {
          name: 'fff',
          count: 6
        }, {
          name: 'ggg',
          count: 7
        }, {
          name: 'hhh',
          count: 8
        }
      ]);
    },
    '複合': function(topic) {
      return assert.deepEqual(topic.ranking({
        border: 5,
        topN: 3,
        asc: true
      }), [
        {
          name: 'eee',
          count: 5
        }, {
          name: 'fff',
          count: 6
        }, {
          name: 'ggg',
          count: 7
        }
      ]);
    }
  }
})["export"](module);
